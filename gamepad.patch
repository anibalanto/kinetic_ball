diff --git a/kinetic_ball/Cargo.toml b/kinetic_ball/Cargo.toml
index 6dc4342..ad98241 100644
--- a/kinetic_ball/Cargo.toml
+++ b/kinetic_ball/Cargo.toml
@@ -42,3 +42,6 @@ arboard = { version = "3.4", features = ["wayland-data-control"] }
 
 # File dialog para seleccionar mapas
 rfd = "0.15"
+
+# Gamepad input directo (para gamepads gen茅ricos que gilrs/bevy no reconoce bien)
+gilrs = "0.11"
diff --git a/kinetic_ball/src/keybindings.rs b/kinetic_ball/src/keybindings.rs
index 27763a8..9b2b66c 100644
--- a/kinetic_ball/src/keybindings.rs
+++ b/kinetic_ball/src/keybindings.rs
@@ -2,6 +2,7 @@ use bevy::prelude::*;
 use serde::{Deserialize, Serialize};
 use std::fs;
 use std::path::PathBuf;
+use std::sync::{Arc, Mutex};
 
 // ============================================
 // SerializableKeyCode - Wrapper para serde
@@ -424,3 +425,223 @@ pub fn load_app_config() -> AppConfig {
         }
     }
 }
+
+// ============================================
+// Gamepad Bindings - Para gamepads gen茅ricos
+// ============================================
+
+/// Tipo de input para un binding de gamepad
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
+pub enum RawGamepadInput {
+    /// Bot贸n por n煤mero (0, 1, 2, etc.)
+    Button(u8),
+    /// Eje positivo (valor > threshold)
+    AxisPositive(u8),
+    /// Eje negativo (valor < -threshold)
+    AxisNegative(u8),
+}
+
+impl RawGamepadInput {
+    pub fn display_name(&self) -> String {
+        match self {
+            RawGamepadInput::Button(n) => format!("Bot贸n {}", n),
+            RawGamepadInput::AxisPositive(n) => format!("Eje {}+", n),
+            RawGamepadInput::AxisNegative(n) => format!("Eje {}-", n),
+        }
+    }
+}
+
+/// Configuraci贸n de bindings para un gamepad gen茅rico
+#[derive(Debug, Clone, Serialize, Deserialize, Resource)]
+pub struct GamepadBindingsConfig {
+    pub move_up: Option<RawGamepadInput>,
+    pub move_down: Option<RawGamepadInput>,
+    pub move_left: Option<RawGamepadInput>,
+    pub move_right: Option<RawGamepadInput>,
+    pub kick: Option<RawGamepadInput>,
+    pub curve_left: Option<RawGamepadInput>,
+    pub curve_right: Option<RawGamepadInput>,
+    pub wildcard: Option<RawGamepadInput>,
+    pub sprint: Option<RawGamepadInput>,
+    pub mode: Option<RawGamepadInput>,
+}
+
+impl Default for GamepadBindingsConfig {
+    fn default() -> Self {
+        Self {
+            // Por defecto, usar ejes 0 y 1 para movimiento
+            move_up: Some(RawGamepadInput::AxisNegative(1)),
+            move_down: Some(RawGamepadInput::AxisPositive(1)),
+            move_left: Some(RawGamepadInput::AxisNegative(0)),
+            move_right: Some(RawGamepadInput::AxisPositive(0)),
+            // Botones t铆picos
+            kick: Some(RawGamepadInput::Button(0)),
+            curve_left: Some(RawGamepadInput::Button(2)),
+            curve_right: Some(RawGamepadInput::Button(1)),
+            wildcard: Some(RawGamepadInput::Button(4)),
+            sprint: Some(RawGamepadInput::Button(5)),
+            mode: Some(RawGamepadInput::Button(3)),
+        }
+    }
+}
+
+impl GamepadBindingsConfig {
+    pub fn get_binding(&self, action: GameAction) -> Option<RawGamepadInput> {
+        match action {
+            GameAction::MoveUp => self.move_up,
+            GameAction::MoveDown => self.move_down,
+            GameAction::MoveLeft => self.move_left,
+            GameAction::MoveRight => self.move_right,
+            GameAction::Kick => self.kick,
+            GameAction::CurveLeft => self.curve_left,
+            GameAction::CurveRight => self.curve_right,
+            GameAction::Wildcard => self.wildcard,
+            GameAction::Sprint => self.sprint,
+            GameAction::Mode => self.mode,
+        }
+    }
+
+    pub fn set_binding(&mut self, action: GameAction, input: Option<RawGamepadInput>) {
+        match action {
+            GameAction::MoveUp => self.move_up = input,
+            GameAction::MoveDown => self.move_down = input,
+            GameAction::MoveLeft => self.move_left = input,
+            GameAction::MoveRight => self.move_right = input,
+            GameAction::Kick => self.kick = input,
+            GameAction::CurveLeft => self.curve_left = input,
+            GameAction::CurveRight => self.curve_right = input,
+            GameAction::Wildcard => self.wildcard = input,
+            GameAction::Sprint => self.sprint = input,
+            GameAction::Mode => self.mode = input,
+        }
+    }
+}
+
+// Persistencia de gamepad bindings
+pub fn get_gamepad_bindings_path() -> Option<PathBuf> {
+    get_config_dir().map(|p| p.join("gamepad_bindings.ron"))
+}
+
+pub fn load_gamepad_bindings() -> GamepadBindingsConfig {
+    let Some(path) = get_gamepad_bindings_path() else {
+        println!("[Config] No se pudo determinar la ruta de gamepad config, usando defaults");
+        return GamepadBindingsConfig::default();
+    };
+
+    match fs::read_to_string(&path) {
+        Ok(content) => match ron::from_str::<GamepadBindingsConfig>(&content) {
+            Ok(config) => {
+                println!("[Config] Gamepad bindings cargados desde {:?}", path);
+                config
+            }
+            Err(e) => {
+                println!(
+                    "[Config] Error parseando gamepad bindings ({}), usando defaults",
+                    e
+                );
+                GamepadBindingsConfig::default()
+            }
+        },
+        Err(_) => {
+            println!("[Config] No existe archivo de gamepad bindings, usando defaults");
+            GamepadBindingsConfig::default()
+        }
+    }
+}
+
+pub fn save_gamepad_bindings(config: &GamepadBindingsConfig) -> Result<(), String> {
+    let config_dir = get_config_dir().ok_or("No se pudo determinar directorio de config")?;
+
+    fs::create_dir_all(&config_dir)
+        .map_err(|e| format!("Error creando directorio de config: {}", e))?;
+
+    let path = config_dir.join("gamepad_bindings.ron");
+
+    let content = ron::ser::to_string_pretty(config, ron::ser::PrettyConfig::default())
+        .map_err(|e| format!("Error serializando config: {}", e))?;
+
+    fs::write(&path, content).map_err(|e| format!("Error escribiendo archivo: {}", e))?;
+
+    println!("[Config] Gamepad bindings guardados en {:?}", path);
+    Ok(())
+}
+
+// ============================================
+// GilrsWrapper - Acceso thread-safe a gilrs
+// ============================================
+
+/// Wrapper thread-safe para gilrs
+#[derive(Resource)]
+pub struct GilrsWrapper {
+    pub gilrs: Arc<Mutex<gilrs::Gilrs>>,
+}
+
+impl GilrsWrapper {
+    pub fn new() -> Option<Self> {
+        match gilrs::Gilrs::new() {
+            Ok(g) => Some(Self {
+                gilrs: Arc::new(Mutex::new(g)),
+            }),
+            Err(e) => {
+                println!("锔 No se pudo inicializar gilrs: {}", e);
+                None
+            }
+        }
+    }
+}
+
+/// Estado actual de un gamepad le铆do por gilrs
+#[derive(Default, Clone)]
+pub struct RawGamepadState {
+    pub buttons: [bool; 32],
+    pub axes: [f32; 8],
+}
+
+impl RawGamepadState {
+    /// Verifica si un input est谩 activo
+    pub fn is_active(&self, input: RawGamepadInput) -> bool {
+        const AXIS_THRESHOLD: f32 = 0.3;
+        match input {
+            RawGamepadInput::Button(n) => self.buttons.get(n as usize).copied().unwrap_or(false),
+            RawGamepadInput::AxisPositive(n) => {
+                self.axes.get(n as usize).copied().unwrap_or(0.0) > AXIS_THRESHOLD
+            }
+            RawGamepadInput::AxisNegative(n) => {
+                self.axes.get(n as usize).copied().unwrap_or(0.0) < -AXIS_THRESHOLD
+            }
+        }
+    }
+}
+
+/// Evento detectado durante configuraci贸n
+#[derive(Debug, Clone)]
+pub enum DetectedInput {
+    Keyboard(KeyCode),
+    Gamepad(RawGamepadInput),
+}
+
+impl DetectedInput {
+    pub fn display_name(&self) -> String {
+        match self {
+            DetectedInput::Keyboard(k) => format!("Tecla: {}", key_code_display_name(*k)),
+            DetectedInput::Gamepad(g) => format!("Gamepad: {}", g.display_name()),
+        }
+    }
+}
+
+/// Estado de UI extendido para configuraci贸n de input
+#[derive(Resource, Default)]
+pub struct InputConfigUIState {
+    /// Acci贸n siendo configurada
+    pub rebinding_action: Option<GameAction>,
+    /// Tipo de dispositivo siendo configurado (0=teclado, 1=gamepad)
+    pub device_tab: usize,
+    /// Bindings pendientes de teclado
+    pub pending_keyboard: Option<KeyBindingsConfig>,
+    /// Bindings pendientes de gamepad
+    pub pending_gamepad: Option<GamepadBindingsConfig>,
+    /// Mensaje de estado
+    pub status_message: Option<String>,
+    /// ltimo input detectado (para mostrar feedback)
+    pub last_detected: Option<DetectedInput>,
+}
diff --git a/kinetic_ball/src/local_players.rs b/kinetic_ball/src/local_players.rs
index 6594667..e528376 100644
--- a/kinetic_ball/src/local_players.rs
+++ b/kinetic_ball/src/local_players.rs
@@ -1,3 +1,4 @@
+use bevy::input::gamepad::{GamepadEvent, RawGamepadEvent};
 use bevy::prelude::*;
 
 // ============================================================================
@@ -164,6 +165,19 @@ pub struct LocalPlayersUIState {
 // SISTEMAS
 // ============================================================================
 
+/// Sistema de debug que muestra eventos raw de gamepad
+pub fn debug_gamepad_events(
+    mut gamepad_events: EventReader<GamepadEvent>,
+    mut raw_events: EventReader<RawGamepadEvent>,
+) {
+    for event in gamepad_events.read() {
+        println!(" [GAMEPAD EVENT] {:?}", event);
+    }
+    for event in raw_events.read() {
+        println!(" [RAW EVENT] {:?}", event);
+    }
+}
+
 /// Sistema que detecta la conexi贸n y desconexi贸n de gamepads
 pub fn detect_gamepads(
     gamepads: Query<(Entity, &Gamepad)>,
@@ -241,6 +255,7 @@ pub fn read_gamepad_input(
     is_cube_mode: bool,
 ) -> PlayerInput {
     let Ok(gamepad) = gamepads.get(gamepad_entity) else {
+        println!(" [ERROR] No se encontr贸 gamepad con entity {:?}", gamepad_entity);
         return PlayerInput::default();
     };
 
@@ -248,6 +263,11 @@ pub fn read_gamepad_input(
     let left_stick_x = gamepad.get(GamepadAxis::LeftStickX).unwrap_or(0.0);
     let left_stick_y = gamepad.get(GamepadAxis::LeftStickY).unwrap_or(0.0);
 
+    // DEBUG: Log del joystick para confirmar que leemos del gamepad correcto
+    if left_stick_x.abs() > 0.1 || left_stick_y.abs() > 0.1 {
+        println!(" [Gamepad] Joystick: x={:.2}, y={:.2}", left_stick_x, left_stick_y);
+    }
+
     // Deadzone
     const DEADZONE: f32 = 0.2;
     let move_left = left_stick_x < -DEADZONE;
@@ -261,6 +281,36 @@ pub fn read_gamepad_input(
     let curve_left = gamepad.pressed(GamepadButton::West); // X/Square
     let mode = gamepad.pressed(GamepadButton::North); // Y/Triangle
 
+    // DEBUG: Log incondicional para ver TODOS los ejes (los botones podr铆an estar ah铆)
+    static mut BTN_LOG_COUNT: u32 = 0;
+    unsafe {
+        BTN_LOG_COUNT += 1;
+        if BTN_LOG_COUNT % 60 == 0 {
+            // Leer todos los ejes posibles
+            let lx = gamepad.get(GamepadAxis::LeftStickX).unwrap_or(0.0);
+            let ly = gamepad.get(GamepadAxis::LeftStickY).unwrap_or(0.0);
+            let rx = gamepad.get(GamepadAxis::RightStickX).unwrap_or(0.0);
+            let ry = gamepad.get(GamepadAxis::RightStickY).unwrap_or(0.0);
+            let lz = gamepad.get(GamepadAxis::LeftZ).unwrap_or(0.0);
+            let rz = gamepad.get(GamepadAxis::RightZ).unwrap_or(0.0);
+
+            println!(
+                " [Ejes] LX={:.2} LY={:.2} RX={:.2} RY={:.2} LZ={:.2} RZ={:.2}",
+                lx, ly, rx, ry, lz, rz
+            );
+
+            // Tambi茅n probar botones
+            let south = gamepad.pressed(GamepadButton::South);
+            let east = gamepad.pressed(GamepadButton::East);
+            let west = gamepad.pressed(GamepadButton::West);
+            let north = gamepad.pressed(GamepadButton::North);
+            println!(
+                " [Botones] S={} E={} W={} N={}",
+                south, east, west, north
+            );
+        }
+    }
+
     // Triggers - intentar como ejes primero, luego como botones
     let left_trigger_axis = gamepad.get(GamepadAxis::LeftZ).unwrap_or(0.0);
     let right_trigger_axis = gamepad.get(GamepadAxis::RightZ).unwrap_or(0.0);
@@ -282,6 +332,14 @@ pub fn read_gamepad_input(
     // Sprint: RT (eje o bot贸n) o RB
     let sprint = right_trigger_axis > TRIGGER_THRESHOLD || right_trigger_btn || right_shoulder;
 
+    // DEBUG: Log triggers
+    if wildcard_pressed || sprint {
+        println!(
+            " [Gamepad] Triggers: LT_axis={:.2}, RT_axis={:.2}, LB={}, RB={}, LT_btn={}, RT_btn={}",
+            left_trigger_axis, right_trigger_axis, left_shoulder, right_shoulder, left_trigger_btn, right_trigger_btn
+        );
+    }
+
     PlayerInput {
         move_up,
         move_down,
diff --git a/kinetic_ball/src/main.rs b/kinetic_ball/src/main.rs
index 11a5d4e..114270c 100644
--- a/kinetic_ball/src/main.rs
+++ b/kinetic_ball/src/main.rs
@@ -25,8 +25,8 @@ use keybindings::{
 
 mod local_players;
 use local_players::{
-    detect_gamepads, read_local_player_input, AvailableInputDevices, InputDevice, LocalPlayer,
-    LocalPlayers, LocalPlayersUIState,
+    debug_gamepad_events, detect_gamepads, read_local_player_input, AvailableInputDevices,
+    InputDevice, LocalPlayer, LocalPlayers, LocalPlayersUIState,
 };
 
 mod host;
@@ -305,8 +305,8 @@ fn main() {
         .insert_resource(LocalPlayersUIState::default())
         // Cargar assets embebidos al inicio (antes de todo)
         .add_systems(Startup, load_embedded_assets)
-        // Detectar gamepads globalmente
-        .add_systems(Update, detect_gamepads)
+        // Detectar gamepads globalmente y debug de eventos
+        .add_systems(Update, (detect_gamepads, debug_gamepad_events))
         // Sistemas de men煤 (solo en estado Menu)
         .add_systems(OnEnter(AppState::Menu), setup_menu_camera_if_needed)
         .add_systems(
@@ -2090,6 +2090,25 @@ fn handle_multi_player_input(
         return;
     }
 
+    // DEBUG: Log una vez cada 60 frames aproximadamente
+    static mut FRAME_COUNT: u32 = 0;
+    unsafe {
+        FRAME_COUNT += 1;
+        if FRAME_COUNT % 120 == 0 {
+            println!(
+                " [DEBUG] {} jugadores locales configurados, gamepads en query: {}",
+                local_players.players.len(),
+                gamepads.iter().count()
+            );
+            for (i, p) in local_players.players.iter().enumerate() {
+                println!(
+                    "   Jugador {}: '{}', device={:?}, server_id={:?}",
+                    i, p.name, p.input_device, p.server_player_id
+                );
+            }
+        }
+    }
+
     // Iterar sobre cada jugador local y enviar su input
     for local_player in &local_players.players {
         // Solo procesar si tiene un server_player_id asignado
